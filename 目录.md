# http
## 状态码 
## 浏览器缓存 
强缓存和协商缓存 

1. 浏览器请求资源  如果没有缓存  向服务器请求 返回请求结果以及缓存标志，存入缓存
2. 有缓存 判断是否是强缓存 判断是否过期 expires绝对时间 catch-control（max-age相对时间） 没有过期 读取缓存 200（expires绝对时间 到期时间可能会随着客户端电脑的本地时间修改导致浏览器判断失误从而影响效果。）
3. 过期 判断是否命中协商缓存 if-modified-since （last-modified）和 if-none-match（etag） 判断是否更新 没有更新 304 读取缓存 
4. 有更新 重新请求 并缓存 200
## web 存储  
cookie   sessionstorage localstorage
生命周期 自己设置过期时间    浏览器关闭  除非删除否则一直存在
大小  4k 5m 5m
与服务器通信  在http头中 仅在客户端  
## 三次握手  四次挥手 
+ 三次握手
1. 客户端发送一个 SYN标识位 包 请求建立连接
2. 服务器收到后 返回一个 SYN和ACK的包 表示同意建立连接
3. 客户端收到后 再次发送一个ACK的包 表示连接成功 开始数据传输 

+ 四次挥手 
1. 客户端 发送一个 FIN的包 请求断开连接 
2. 服务器响应一个携带  ACK 的包  同意客户端断开连接 
3. 服务器再发送一个 携带 FIN的包 表示请求断开连接
4. 客户端发送一个携带 ACK标识位的包 表示同意服务器断开连接 
## 计算机网络  五层协议栈  
应用层  http     报文 
传输层  tcp udp   数据段
网络层   ip    网络主机间通信 数据包   
数据链路层   arp  数据帧 
物理层     比特流  

## udp  tcp
tcp 面向连接 udp无连接 
tcp 提供可靠服务 无差错 不丢失 不重复 按序到达 udp不保证可靠 
tcp 首部开销大20字节  udp 8字节

+ udp 不可靠原因
1. 没有顺序控制  当数据包乱序到达 没有纠正功能
2. 没有重传控制  当数据包丢失 不重发 
3. 在通信时 不需要建立连接
4. 无法进行流量控制 拥塞控制等避免网络拥堵的机制  

## http 0.9 1.0 1.1 2
## https 
https加密 
1. 客户端发送client hello 开始SSL通信 报文中包括协议版本号 加密算法等信息
2. 服务器发送 server hello 报文作为应答  
3. 服务器发送数字证书  数字证书包括服务器的公开密钥
4. 客户端解开并验证数字证书  验证通过后 生成一个随机密码串 再用收到的服务器公钥加密 发送给服务器 
5. 客户端再发送 change cipher spec 报文  提示服务器在此条报文之后 采用刚刚生成的随机密码串 进行数据加密 
6. 服务器也发送  change cipher spec 报文
7. ssl连接完成  
>https 采用混合加密 在交换公钥阶段使用非对称加密  在传输报文阶段使用对称加密    
## URL从输入到渲染     
1. dns 解析IP地址
2. 浏览器发送请求 与服务端进行数据交互
3. 浏览器对页面进行渲染 

> 1. 查找浏览器dns缓存 => 操作系统dns缓存 => 路由器dns缓存 => 网络服务商dns缓存 => 根服务器DNS缓存  上述过程不断向外扩散，为的就是最小成本匹配解析 IP 地址，上述过程只要其中一个匹配上，就不会继续向外寻找，越向外越耗时。
> 2.  tcp 三次握手建立连接 其次，浏览器向服务器发起获取指定 HTML 页面的 HTTP GET 请求；

然后，服务器接收请求，将指定的页面 HTML 返回给前端；

最后，前端根据响应进行处理，如果是200状态码，表示获取成功，开始页面渲染。
> 3. 渲染 
首先，浏览器深度遍历 HTML 节点内容生成 DOM 树；

其次，将 HTML 内的 CSS 解析成 CSS DOM 树；

然后，将上面两颗树 DOM 树和 CSSOM 树 合并成渲染树 Render Tree；

再然后，根据渲染树进行页面所有节点的布局 Layout，也就是确定位置（回流）；

最后，布局完成之后调用相应 API 对节点进行绘制（重绘）。



# vue 
## 生命周期  
## v-if v-show
## key  
## dom树
## data函数  


# js
## 基本类型以及 API
## 堆栈   
## 闭包  继承     

# es6
## let const  var   
## promise 



# css +  html   
## 动效

# webpack 
只能打包js文件 其他文件要调用loader 
css-loader分析css文件关系 将多个css融合成一个css文件=>css-loader输出作为style-loader的输入 style-loader 将其挂载到页面<head>中的<style>


插件(plugins)： 在某个时间点自动执行的处理程序（类似Vue的生命周期函数）
loader：处理不同文件的加载器
